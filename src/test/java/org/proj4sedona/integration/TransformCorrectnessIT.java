package org.proj4sedona.integration;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.TestFactory;
import org.proj4sedona.Proj4;
import org.proj4sedona.core.Point;
import org.proj4sedona.projection.ProjectionRegistry;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.DynamicTest.dynamicTest;

/**
 * Integration tests for coordinate transformation correctness.
 * 
 * <p>These tests compare proj4sedona transformation results against reference
 * data generated by pyproj to ensure compatibility and correctness.</p>
 * 
 * <p>Test cases cover:</p>
 * <ul>
 *   <li>Common EPSG codes (4326, 3857, UTM zones)</li>
 *   <li>Datum transformations</li>
 *   <li>Edge cases (poles, dateline)</li>
 * </ul>
 */
public class TransformCorrectnessIT {

    private static final String REFERENCE_FILE = "/pyproj-reference/transform_reference.json";
    
    // Tolerances
    private static final double GEOGRAPHIC_TOLERANCE = 1e-6;  // ~0.1m at equator
    private static final double PROJECTED_TOLERANCE = 0.01;   // 1cm
    
    private static JsonObject referenceData;
    
    @BeforeAll
    static void setup() throws IOException {
        // Initialize projection registry
        ProjectionRegistry.start();
        
        // Load reference data
        referenceData = loadReferenceData();
        
        assertNotNull(referenceData, "Reference data should be loaded");
        assertTrue(referenceData.has("test_cases"), "Reference data should have test_cases");
    }
    
    private static JsonObject loadReferenceData() throws IOException {
        try (InputStream is = TransformCorrectnessIT.class.getResourceAsStream(REFERENCE_FILE)) {
            if (is == null) {
                throw new IOException("Reference file not found: " + REFERENCE_FILE);
            }
            Gson gson = new Gson();
            return gson.fromJson(new InputStreamReader(is, StandardCharsets.UTF_8), JsonObject.class);
        }
    }
    
    @TestFactory
    @DisplayName("Transformation correctness tests")
    Collection<DynamicTest> transformationTests() {
        List<DynamicTest> tests = new ArrayList<>();
        
        JsonArray testCases = referenceData.getAsJsonArray("test_cases");
        
        for (JsonElement element : testCases) {
            JsonObject testCase = element.getAsJsonObject();
            String testName = testCase.get("name").getAsString();
            String description = testCase.get("description").getAsString();
            
            // Skip if test case has error
            if (testCase.has("error") && !testCase.get("error").isJsonNull()) {
                tests.add(dynamicTest(testName + " (skipped - reference error)", () -> {
                    // Log the skip reason
                    System.out.println("Skipping " + testName + ": " + testCase.get("error").getAsString());
                }));
                continue;
            }
            
            String fromCrs = testCase.get("from_crs").getAsString();
            String toCrs = testCase.get("to_crs").getAsString();
            JsonArray transformations = testCase.getAsJsonArray("transformations");
            
            // Create a test for each transformation in the test case
            for (JsonElement transElement : transformations) {
                JsonObject transformation = transElement.getAsJsonObject();
                String coordName = transformation.get("coordinate_name").getAsString();
                
                // Skip if transformation has error
                if (transformation.has("error") && !transformation.get("error").isJsonNull()) {
                    continue;
                }
                
                JsonObject input = transformation.getAsJsonObject("input");
                JsonObject expectedOutput = transformation.getAsJsonObject("output");
                
                if (expectedOutput == null || expectedOutput.isJsonNull()) {
                    continue;
                }
                
                double inputX = input.get("x").getAsDouble();
                double inputY = input.get("y").getAsDouble();
                double expectedX = expectedOutput.get("x").getAsDouble();
                double expectedY = expectedOutput.get("y").getAsDouble();
                
                String fullTestName = String.format("%s: %s (%s)", testName, coordName, description);
                
                tests.add(dynamicTest(fullTestName, () -> {
                    testTransformation(fromCrs, toCrs, inputX, inputY, expectedX, expectedY);
                }));
            }
        }
        
        return tests;
    }
    
    private void testTransformation(String fromCrs, String toCrs, 
                                     double inputX, double inputY,
                                     double expectedX, double expectedY) {
        try {
            // Perform transformation using proj4sedona
            Point result = Proj4.proj4(fromCrs, toCrs, new Point(inputX, inputY));
            
            assertNotNull(result, "Transformation result should not be null");
            assertFalse(Double.isNaN(result.x), "Result X should not be NaN");
            assertFalse(Double.isNaN(result.y), "Result Y should not be NaN");
            
            // Determine tolerance based on CRS type
            double tolerance = isProjectedCrs(toCrs) ? PROJECTED_TOLERANCE : GEOGRAPHIC_TOLERANCE;
            
            // Compare results
            assertEquals(expectedX, result.x, tolerance,
                String.format("X coordinate mismatch: expected %f, got %f", expectedX, result.x));
            assertEquals(expectedY, result.y, tolerance,
                String.format("Y coordinate mismatch: expected %f, got %f", expectedY, result.y));
            
        } catch (Exception e) {
            fail("Transformation failed: " + e.getMessage());
        }
    }
    
    private boolean isProjectedCrs(String crs) {
        // Simple heuristic: check if it's a projected CRS
        if (crs.startsWith("EPSG:")) {
            String code = crs.substring(5);
            try {
                int epsgCode = Integer.parseInt(code);
                // UTM zones, Web Mercator, etc. are projected
                return epsgCode >= 32600 || epsgCode == 3857;
            } catch (NumberFormatException e) {
                return false;
            }
        }
        return crs.contains("+proj=") && !crs.contains("+proj=longlat");
    }
    
    @TestFactory
    @DisplayName("Round-trip transformation tests")
    Collection<DynamicTest> roundTripTests() {
        List<DynamicTest> tests = new ArrayList<>();
        
        // Define round-trip test cases
        Object[][] roundTripCases = {
            {"EPSG:4326", "EPSG:3857", -122.4194, 37.7749, "San Francisco"},
            {"EPSG:4326", "EPSG:32610", -122.4194, 37.7749, "San Francisco UTM 10N"},
            {"EPSG:4326", "EPSG:32632", 9.0, 48.0, "Stuttgart UTM 32N"},
        };
        
        for (Object[] testCase : roundTripCases) {
            String fromCrs = (String) testCase[0];
            String toCrs = (String) testCase[1];
            double lon = (Double) testCase[2];
            double lat = (Double) testCase[3];
            String name = (String) testCase[4];
            
            tests.add(dynamicTest("Round-trip: " + name, () -> {
                testRoundTrip(fromCrs, toCrs, lon, lat);
            }));
        }
        
        return tests;
    }
    
    private void testRoundTrip(String fromCrs, String toCrs, double lon, double lat) {
        Point original = new Point(lon, lat);
        
        // Forward transformation
        Point projected = Proj4.proj4(fromCrs, toCrs, original);
        assertNotNull(projected, "Forward transformation should succeed");
        
        // Inverse transformation
        Point restored = Proj4.proj4(toCrs, fromCrs, projected);
        assertNotNull(restored, "Inverse transformation should succeed");
        
        // Verify round-trip
        assertEquals(lon, restored.x, GEOGRAPHIC_TOLERANCE,
            "Longitude should be preserved in round-trip");
        assertEquals(lat, restored.y, GEOGRAPHIC_TOLERANCE,
            "Latitude should be preserved in round-trip");
    }
}
