package org.datasyslab.proj4sedona.integration;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.TestFactory;
import org.datasyslab.proj4sedona.Proj4;
import org.datasyslab.proj4sedona.core.Point;
import org.datasyslab.proj4sedona.projection.ProjectionRegistry;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Assumptions.*;
import static org.junit.jupiter.api.DynamicTest.dynamicTest;

/**
 * Integration tests for coordinate transformation correctness.
 * 
 * <p>These tests compare proj4sedona transformation results against reference
 * data generated by pyproj to ensure compatibility and correctness.</p>
 * 
 * <h2>Supported Test Cases</h2>
 * <ul>
 *   <li>Common EPSG codes (4326, 3857, UTM zones)</li>
 *   <li>WGS84 to NAD83 (same ellipsoid, no datum shift needed)</li>
 *   <li>Projection transformations (LCC, UPS North/South)</li>
 *   <li>Edge cases (poles, dateline)</li>
 * </ul>
 * 
 * <h2>Skipped Test Cases (Documented Limitations)</h2>
 * <p>The following test cases are skipped because they require datum transformation
 * parameters that are not embedded in proj4sedona's EPSG definitions:</p>
 * <ul>
 *   <li><b>osgb36_to_wgs84</b>: EPSG:4277 to EPSG:4326 - requires towgs84 or grid-based transformation</li>
 *   <li><b>ed50_to_wgs84</b>: EPSG:4230 to EPSG:4326 - requires towgs84 or grid-based transformation</li>
 * </ul>
 * 
 * <h2>Workaround for Skipped Tests</h2>
 * <p>Users can work around this limitation by using explicit PROJ strings with towgs84
 * parameters or nadgrids. For example:</p>
 * <pre>
 * // Instead of: EPSG:4277 (OSGB36) -> EPSG:4326 (WGS84)
 * // Use explicit PROJ string with towgs84 (approximate 7-parameter transformation):
 * String osgb36 = "+proj=longlat +ellps=airy +towgs84=446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894 +no_defs";
 * String wgs84 = "+proj=longlat +datum=WGS84 +no_defs";
 * </pre>
 * 
 * <h2>Why These Tests Are Skipped</h2>
 * <p>PROJ/pyproj uses a sophisticated transformation registry that can automatically
 * select the best transformation method (including grid-based transforms) based on
 * the source and target CRS. proj4sedona currently does not have this feature and
 * requires explicit transformation parameters in the CRS definition.</p>
 * 
 * <h2>Future Work</h2>
 * <p>To support these datum transformations, proj4sedona would need to:</p>
 * <ol>
 *   <li>Embed towgs84 parameters in EPSG definitions for common datums</li>
 *   <li>Implement a transformation registry for automatic method selection</li>
 *   <li>Support transformation pipelines</li>
 * </ol>
 * 
 * @see <a href="https://proj.org/operations/transformations/index.html">PROJ Transformations</a>
 */
public class TransformCorrectnessIT {

    private static final String REFERENCE_FILE = "/pyproj-reference/transform_reference.json";
    
    // Tolerances
    private static final double GEOGRAPHIC_TOLERANCE = 1e-6;  // ~0.1m at equator
    private static final double PROJECTED_TOLERANCE = 0.01;   // 1cm
    private static final double RELATIVE_TOLERANCE = 1e-9;    // For very large values
    
    /**
     * Test cases that require datum transformation parameters not embedded in proj4sedona.
     * These tests are skipped because the EPSG definitions in proj4sedona don't include
     * towgs84 parameters, and proj4sedona doesn't support automatic transformation
     * pipeline discovery like PROJ/pyproj.
     * 
     * See class Javadoc for workarounds and future work needed.
     */
    private static final Set<String> SKIPPED_TEST_CASES = Set.of(
        "osgb36_to_wgs84",  // EPSG:4277 -> EPSG:4326 - requires towgs84 or OSTN grid
        "ed50_to_wgs84"     // EPSG:4230 -> EPSG:4326 - requires towgs84 parameters
    );
    
    private static JsonObject referenceData;
    
    @BeforeAll
    static void setup() throws IOException {
        // Initialize projection registry
        ProjectionRegistry.start();
        
        // Load reference data
        referenceData = loadReferenceData();
        
        assertNotNull(referenceData, "Reference data should be loaded");
        assertTrue(referenceData.has("test_cases"), "Reference data should have test_cases");
    }
    
    private static JsonObject loadReferenceData() throws IOException {
        try (InputStream is = TransformCorrectnessIT.class.getResourceAsStream(REFERENCE_FILE)) {
            if (is == null) {
                throw new IOException("Reference file not found: " + REFERENCE_FILE);
            }
            Gson gson = new Gson();
            return gson.fromJson(new InputStreamReader(is, StandardCharsets.UTF_8), JsonObject.class);
        }
    }
    
    @TestFactory
    @DisplayName("Transformation correctness tests")
    Collection<DynamicTest> transformationTests() {
        List<DynamicTest> tests = new ArrayList<>();
        
        JsonArray testCases = referenceData.getAsJsonArray("test_cases");
        
        for (JsonElement element : testCases) {
            JsonObject testCase = element.getAsJsonObject();
            String testName = testCase.get("name").getAsString();
            String description = testCase.get("description").getAsString();
            
            // Skip tests that require datum transformation parameters not in proj4sedona
            if (SKIPPED_TEST_CASES.contains(testName)) {
                String fromCrs = testCase.get("from_crs").getAsString();
                String toCrs = testCase.get("to_crs").getAsString();
                tests.add(dynamicTest(testName + " (skipped - requires datum parameters)", () -> {
                    System.out.println("[SKIPPED] " + testName + ": " + description);
                    System.out.println("  Reason: Requires towgs84 parameters or transformation registry (not yet implemented)");
                    System.out.println("  From CRS: " + fromCrs);
                    System.out.println("  To CRS: " + toCrs);
                    System.out.println("  Workaround: Use explicit PROJ string with +towgs84 parameter");
                    assumeTrue(false,
                        "Test '" + testName + "' requires datum transformation parameters not embedded in proj4sedona. " +
                        "Use explicit PROJ strings with +towgs84 parameter as a workaround. " +
                        "See TransformCorrectnessIT class Javadoc for details.");
                }));
                continue;
            }
            
            // Skip if test case has error
            if (testCase.has("error") && !testCase.get("error").isJsonNull()) {
                tests.add(dynamicTest(testName + " (skipped - reference error)", () -> {
                    // Log the skip reason
                    System.out.println("Skipping " + testName + ": " + testCase.get("error").getAsString());
                }));
                continue;
            }
            
            String fromCrs = testCase.get("from_crs").getAsString();
            String toCrs = testCase.get("to_crs").getAsString();
            JsonArray transformations = testCase.getAsJsonArray("transformations");
            
            // Create a test for each transformation in the test case
            for (JsonElement transElement : transformations) {
                JsonObject transformation = transElement.getAsJsonObject();
                String coordName = transformation.get("coordinate_name").getAsString();
                
                // Skip if transformation has error
                if (transformation.has("error") && !transformation.get("error").isJsonNull()) {
                    continue;
                }
                
                JsonObject input = transformation.getAsJsonObject("input");
                JsonObject expectedOutput = transformation.getAsJsonObject("output");
                
                if (expectedOutput == null || expectedOutput.isJsonNull()) {
                    continue;
                }
                
                double inputX = input.get("x").getAsDouble();
                double inputY = input.get("y").getAsDouble();
                double expectedX = expectedOutput.get("x").getAsDouble();
                double expectedY = expectedOutput.get("y").getAsDouble();
                
                String fullTestName = String.format("%s: %s (%s)", testName, coordName, description);
                
                tests.add(dynamicTest(fullTestName, () -> {
                    testTransformation(fromCrs, toCrs, inputX, inputY, expectedX, expectedY);
                }));
            }
        }
        
        return tests;
    }
    
    private void testTransformation(String fromCrs, String toCrs, 
                                     double inputX, double inputY,
                                     double expectedX, double expectedY) {
        try {
            // Perform transformation using proj4sedona
            Point result = Proj4.proj4(fromCrs, toCrs, new Point(inputX, inputY));
            
            assertNotNull(result, "Transformation result should not be null");
            assertFalse(Double.isNaN(result.x), "Result X should not be NaN");
            assertFalse(Double.isNaN(result.y), "Result Y should not be NaN");
            
            // Calculate tolerances - use relative tolerance for large values
            double xTolerance = computeTolerance(expectedX, toCrs);
            double yTolerance = computeTolerance(expectedY, toCrs);
            
            // Compare results
            assertEquals(expectedX, result.x, xTolerance,
                String.format("X coordinate mismatch: expected %f, got %f", expectedX, result.x));
            assertEquals(expectedY, result.y, yTolerance,
                String.format("Y coordinate mismatch: expected %f, got %f", expectedY, result.y));
            
        } catch (Exception e) {
            fail("Transformation failed: " + e.getMessage());
        }
    }
    
    /**
     * Compute appropriate tolerance based on expected value magnitude and CRS type.
     * For very large values (e.g., polar projections with values in billions of meters),
     * we use relative tolerance to account for floating-point precision limits.
     */
    private double computeTolerance(double expectedValue, String toCrs) {
        double baseTolerance = isProjectedCrs(toCrs) ? PROJECTED_TOLERANCE : GEOGRAPHIC_TOLERANCE;
        double absExpected = Math.abs(expectedValue);
        
        // For values > 1 million, use relative tolerance if it's larger than base tolerance
        if (absExpected > 1_000_000) {
            double relativeTol = absExpected * RELATIVE_TOLERANCE;
            return Math.max(baseTolerance, relativeTol);
        }
        
        return baseTolerance;
    }
    
    private boolean isProjectedCrs(String crs) {
        // Simple heuristic: check if it's a projected CRS
        if (crs.startsWith("EPSG:")) {
            String code = crs.substring(5);
            try {
                int epsgCode = Integer.parseInt(code);
                // UTM zones, Web Mercator, etc. are projected
                return epsgCode >= 32600 || epsgCode == 3857;
            } catch (NumberFormatException e) {
                return false;
            }
        }
        return crs.contains("+proj=") && !crs.contains("+proj=longlat");
    }
    
    @TestFactory
    @DisplayName("Round-trip transformation tests")
    Collection<DynamicTest> roundTripTests() {
        List<DynamicTest> tests = new ArrayList<>();
        
        // Define round-trip test cases
        Object[][] roundTripCases = {
            {"EPSG:4326", "EPSG:3857", -122.4194, 37.7749, "San Francisco"},
            {"EPSG:4326", "EPSG:32610", -122.4194, 37.7749, "San Francisco UTM 10N"},
            {"EPSG:4326", "EPSG:32632", 9.0, 48.0, "Stuttgart UTM 32N"},
        };
        
        for (Object[] testCase : roundTripCases) {
            String fromCrs = (String) testCase[0];
            String toCrs = (String) testCase[1];
            double lon = (Double) testCase[2];
            double lat = (Double) testCase[3];
            String name = (String) testCase[4];
            
            tests.add(dynamicTest("Round-trip: " + name, () -> {
                testRoundTrip(fromCrs, toCrs, lon, lat);
            }));
        }
        
        return tests;
    }
    
    private void testRoundTrip(String fromCrs, String toCrs, double lon, double lat) {
        Point original = new Point(lon, lat);
        
        // Forward transformation
        Point projected = Proj4.proj4(fromCrs, toCrs, original);
        assertNotNull(projected, "Forward transformation should succeed");
        
        // Inverse transformation
        Point restored = Proj4.proj4(toCrs, fromCrs, projected);
        assertNotNull(restored, "Inverse transformation should succeed");
        
        // Verify round-trip
        assertEquals(lon, restored.x, GEOGRAPHIC_TOLERANCE,
            "Longitude should be preserved in round-trip");
        assertEquals(lat, restored.y, GEOGRAPHIC_TOLERANCE,
            "Latitude should be preserved in round-trip");
    }
}
