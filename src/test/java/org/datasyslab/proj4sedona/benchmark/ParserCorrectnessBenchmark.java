package org.datasyslab.proj4sedona.benchmark;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.TestFactory;
import org.datasyslab.proj4sedona.core.Proj;
import org.datasyslab.proj4sedona.projection.ProjectionParams;
import org.datasyslab.proj4sedona.projection.ProjectionRegistry;

import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.DynamicTest.dynamicTest;

/**
 * Correctness benchmarks for CRS parsing.
 * 
 * <p>These tests compare proj4sedona CRS parsing results against reference
 * data generated by pyproj to ensure compatibility.</p>
 * 
 * <p>Test cases cover parsing of:</p>
 * <ul>
 *   <li>EPSG codes</li>
 *   <li>PROJ strings</li>
 *   <li>WKT1 strings</li>
 *   <li>WKT2 strings</li>
 * </ul>
 */
public class ParserCorrectnessBenchmark {

    private static final Path REFERENCE_FILE = Paths.get("target/pyproj-reference/parsing_reference.json");
    
    // Tolerances for parameter comparison
    private static final double ELLIPSOID_TOLERANCE = 0.1;     // 10cm for ellipsoid params
    private static final double ANGLE_TOLERANCE = 1e-6;        // ~0.1m at equator
    private static final double LINEAR_TOLERANCE = 0.01;       // 1cm
    
    private static JsonObject referenceData;
    
    @BeforeAll
    static void setup() throws IOException {
        // Initialize projection registry
        ProjectionRegistry.start();
        
        // Load reference data
        referenceData = loadReferenceData();
        
        assertNotNull(referenceData, "Reference data should be loaded");
    }
    
    private static JsonObject loadReferenceData() throws IOException {
        if (!Files.exists(REFERENCE_FILE)) {
            throw new IOException("Reference file not found: " + REFERENCE_FILE + 
                ". Run 'mvn verify -Pbenchmarks' to generate pyproj reference data.");
        }
        Gson gson = new Gson();
        return gson.fromJson(new InputStreamReader(Files.newInputStream(REFERENCE_FILE), StandardCharsets.UTF_8), JsonObject.class);
    }
    
    @TestFactory
    @DisplayName("EPSG code parsing tests")
    Collection<DynamicTest> epsgParsingTests() {
        List<DynamicTest> tests = new ArrayList<>();
        
        if (!referenceData.has("epsg_test_cases")) {
            return tests;
        }
        
        JsonArray testCases = referenceData.getAsJsonArray("epsg_test_cases");
        
        for (JsonElement element : testCases) {
            JsonObject testCase = element.getAsJsonObject();
            String input = testCase.get("input").getAsString();
            String description = testCase.get("description").getAsString();
            
            // Skip if test case has error
            if (testCase.has("error") && !testCase.get("error").isJsonNull()) {
                continue;
            }
            
            JsonObject parsedParams = testCase.getAsJsonObject("parsed_params");
            if (parsedParams == null) {
                continue;
            }
            
            String testName = String.format("Parse %s (%s)", input, description);
            
            tests.add(dynamicTest(testName, () -> {
                testEpsgParsing(input, parsedParams);
            }));
        }
        
        return tests;
    }
    
    private void testEpsgParsing(String epsgCode, JsonObject expectedParams) {
        try {
            Proj proj = new Proj(epsgCode);
            assertNotNull(proj, "Proj should be created for " + epsgCode);
            
            ProjectionParams params = proj.getParams();
            assertNotNull(params, "Params should not be null");
            
            // Check CRS type
            if (expectedParams.has("is_geographic")) {
                boolean expectedGeographic = expectedParams.get("is_geographic").getAsBoolean();
                boolean actualGeographic = "longlat".equals(params.projName);
                assertEquals(expectedGeographic, actualGeographic,
                    "Geographic flag mismatch for " + epsgCode);
            }
            
            // Check ellipsoid parameters
            if (expectedParams.has("ellipsoid")) {
                JsonObject ellipsoid = expectedParams.getAsJsonObject("ellipsoid");
                
                if (ellipsoid.has("semi_major_metre")) {
                    double expectedA = ellipsoid.get("semi_major_metre").getAsDouble();
                    assertEquals(expectedA, params.a, ELLIPSOID_TOLERANCE,
                        "Semi-major axis mismatch for " + epsgCode);
                }
                
                if (ellipsoid.has("inverse_flattening")) {
                    double expectedRf = ellipsoid.get("inverse_flattening").getAsDouble();
                    if (params.rf > 0) {
                        assertEquals(expectedRf, params.rf, 0.0001,
                            "Inverse flattening mismatch for " + epsgCode);
                    }
                }
            }
            
            // Check projection parameters for projected CRS
            if (expectedParams.has("projection_params")) {
                JsonObject projParams = expectedParams.getAsJsonObject("projection_params");
                verifyProjectionParams(epsgCode, params, projParams);
            }
            
        } catch (Exception e) {
            fail("Failed to parse " + epsgCode + ": " + e.getMessage());
        }
    }
    
    @TestFactory
    @DisplayName("PROJ string parsing tests")
    Collection<DynamicTest> projStringParsingTests() {
        List<DynamicTest> tests = new ArrayList<>();
        
        if (!referenceData.has("proj_string_test_cases")) {
            return tests;
        }
        
        JsonArray testCases = referenceData.getAsJsonArray("proj_string_test_cases");
        
        for (JsonElement element : testCases) {
            JsonObject testCase = element.getAsJsonObject();
            String input = testCase.get("input").getAsString();
            String description = testCase.get("description").getAsString();
            
            // Skip if test case has error
            if (testCase.has("error") && !testCase.get("error").isJsonNull()) {
                continue;
            }
            
            JsonObject parsedParams = testCase.getAsJsonObject("parsed_params");
            if (parsedParams == null) {
                continue;
            }
            
            String testName = String.format("Parse PROJ: %s", description);
            
            tests.add(dynamicTest(testName, () -> {
                testProjStringParsing(input, parsedParams);
            }));
        }
        
        return tests;
    }
    
    private void testProjStringParsing(String projString, JsonObject expectedParams) {
        try {
            Proj proj = new Proj(projString);
            assertNotNull(proj, "Proj should be created for PROJ string");
            
            ProjectionParams params = proj.getParams();
            assertNotNull(params, "Params should not be null");
            
            // Check CRS type
            if (expectedParams.has("is_geographic")) {
                boolean expectedGeographic = expectedParams.get("is_geographic").getAsBoolean();
                boolean actualGeographic = "longlat".equals(params.projName);
                assertEquals(expectedGeographic, actualGeographic, "Geographic flag mismatch");
            }
            
            if (expectedParams.has("is_projected")) {
                boolean expectedProjected = expectedParams.get("is_projected").getAsBoolean();
                boolean actualProjected = !"longlat".equals(params.projName);
                assertEquals(expectedProjected, actualProjected, "Projected flag mismatch");
            }
            
        } catch (Exception e) {
            fail("Failed to parse PROJ string: " + e.getMessage());
        }
    }
    
    @TestFactory
    @DisplayName("WKT parsing tests")
    Collection<DynamicTest> wktParsingTests() {
        List<DynamicTest> tests = new ArrayList<>();
        
        if (!referenceData.has("wkt_test_cases")) {
            return tests;
        }
        
        JsonArray testCases = referenceData.getAsJsonArray("wkt_test_cases");
        
        for (JsonElement element : testCases) {
            JsonObject testCase = element.getAsJsonObject();
            String input = testCase.get("input").getAsString();
            String format = testCase.get("input_format").getAsString();
            String description = testCase.get("description").getAsString();
            
            // Skip if test case has error
            if (testCase.has("error") && !testCase.get("error").isJsonNull()) {
                continue;
            }
            
            JsonObject parsedParams = testCase.getAsJsonObject("parsed_params");
            if (parsedParams == null) {
                continue;
            }
            
            String testName = String.format("Parse %s: %s", format, description);
            
            tests.add(dynamicTest(testName, () -> {
                testWktParsing(input, format, parsedParams);
            }));
        }
        
        return tests;
    }
    
    private void testWktParsing(String wkt, String format, JsonObject expectedParams) {
        try {
            Proj proj = new Proj(wkt);
            assertNotNull(proj, "Proj should be created from " + format);
            
            ProjectionParams params = proj.getParams();
            assertNotNull(params, "Params should not be null");
            
            // Check CRS type
            if (expectedParams.has("is_geographic")) {
                boolean expectedGeographic = expectedParams.get("is_geographic").getAsBoolean();
                boolean actualGeographic = "longlat".equals(params.projName);
                assertEquals(expectedGeographic, actualGeographic,
                    "Geographic flag mismatch for " + format);
            }
            
        } catch (Exception e) {
            fail("Failed to parse " + format + ": " + e.getMessage());
        }
    }
    
    private void verifyProjectionParams(String crsCode, ProjectionParams actual, JsonObject expected) {
        // Check scale factor
        if (expected.has("Scale factor at natural origin")) {
            double expectedK = expected.get("Scale factor at natural origin").getAsDouble();
            assertEquals(expectedK, actual.k0, 1e-6,
                "Scale factor mismatch for " + crsCode);
        }
        
        // Check false easting
        if (expected.has("False easting")) {
            double expectedX0 = expected.get("False easting").getAsDouble();
            assertEquals(expectedX0, actual.x0, LINEAR_TOLERANCE,
                "False easting mismatch for " + crsCode);
        }
        
        // Check false northing
        if (expected.has("False northing")) {
            double expectedY0 = expected.get("False northing").getAsDouble();
            assertEquals(expectedY0, actual.y0, LINEAR_TOLERANCE,
                "False northing mismatch for " + crsCode);
        }
    }
}
